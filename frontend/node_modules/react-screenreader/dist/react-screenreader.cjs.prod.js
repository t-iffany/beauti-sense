"use strict";

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var React = require("react");

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [], _n = !0, _d = !1, _e = void 0;
  try {
    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
    !i || _arr.length !== i); _n = !0) ;
  } catch (err) {
    _d = !0, _e = err;
  } finally {
    try {
      _n || null == _i.return || _i.return();
    } finally {
      if (_d) throw _e;
    }
  }
  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _defineProperty(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value: value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {}, ownKeys = Object.keys(source);
    "function" == typeof Object.getOwnPropertySymbols && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}

var actionTypes = {
  FOCUS: "FOCUS",
  BLUR: "BLUR",
  SET: "SET"
}, initialState = {}, elementReducer = function(state, action) {
  switch (action.type) {
   case actionTypes.FOCUS:
    return _objectSpread({}, Object.keys(state).reduce(function(a, c) {
      return a[c] = _objectSpread({}, a[c], {
        focused: !1
      }), a;
    }, {}), _defineProperty({}, action.message, _objectSpread({}, state[action.message], {
      focused: !0
    })));

   case actionTypes.BLUR:
    return _objectSpread({}, state, _defineProperty({}, action.message, _objectSpread({}, state[action.message], {
      focused: !1
    })));

   case actionTypes.SET:
    return _objectSpread({}, state, _defineProperty({}, action.message, {
      handlers: action.handlers,
      focused: !1
    }));

   default:
    return state;
  }
}, AriaLiveMessage = function(props) {
  return React.createElement("span", Object.assign({
    style: {
      zIndex: 999999,
      border: 0,
      clip: "rect(1px, 1px, 1px, 1px)",
      height: 0,
      width: 0,
      position: "absolute",
      overflow: "hidden",
      padding: 0,
      whiteSpace: "nowrap"
    },
    className: "a11y-text"
  }, props));
}, useScreenReader = function() {
  var _React$useReducer2 = _slicedToArray(React.useReducer(elementReducer, initialState), 2), state = _React$useReducer2[0], dispatch = _React$useReducer2[1], a11y = React.useCallback(function() {
    var message = Object.keys(state).find(function(x) {
      return state[x].focused;
    });
    return message ? React.createElement(AriaLiveMessage, {
      "aria-live": "polite"
    }, React.createElement("p", null, message)) : null;
  }, [ state ]), createEventHandlers = React.useCallback(function(message) {
    return {
      onFocus: function() {
        return dispatch({
          type: actionTypes.FOCUS,
          message: message
        });
      },
      onBlur: function() {
        return dispatch({
          type: actionTypes.BLUR,
          message: message
        });
      }
    };
  }, []);
  return {
    a11y: a11y,
    reader: React.useCallback(function(message) {
      if (!state[message]) {
        var handlers = createEventHandlers(message);
        return dispatch({
          type: actionTypes.SET,
          message: message,
          handlers: handlers
        }), handlers;
      }
      return state[message].handlers;
    }, [ state ]),
    read: function(message) {
      return dispatch({
        type: actionTypes.FOCUS,
        message: message
      });
    }
  };
};

exports.default = useScreenReader;
