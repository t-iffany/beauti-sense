'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var React = require('react');

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

var actionTypes = {
  FOCUS: "FOCUS",
  BLUR: "BLUR",
  SET: "SET"
};
var initialState = {};

var elementReducer = function elementReducer(state, action) {
  switch (action.type) {
    case actionTypes.FOCUS:
      return _objectSpread({}, Object.keys(state).reduce(function (a, c) {
        a[c] = _objectSpread({}, a[c], {
          focused: false
        });
        return a;
      }, {}), _defineProperty({}, action.message, _objectSpread({}, state[action.message], {
        focused: true
      })));

    case actionTypes.BLUR:
      return _objectSpread({}, state, _defineProperty({}, action.message, _objectSpread({}, state[action.message], {
        focused: false
      })));

    case actionTypes.SET:
      return _objectSpread({}, state, _defineProperty({}, action.message, {
        handlers: action.handlers,
        focused: false
      }));

    default:
      return state;
  }
};

var AriaLiveMessage = function AriaLiveMessage(props) {
  return React.createElement("span", Object.assign({
    style: {
      zIndex: 999999,
      border: 0,
      clip: "rect(1px, 1px, 1px, 1px)",
      height: 0,
      width: 0,
      position: "absolute",
      overflow: "hidden",
      padding: 0,
      whiteSpace: "nowrap"
    },
    className: "a11y-text"
  }, props));
};

var useScreenReader = function useScreenReader() {
  var _React$useReducer = React.useReducer(elementReducer, initialState),
      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
      state = _React$useReducer2[0],
      dispatch = _React$useReducer2[1];

  var a11y = React.useCallback(function () {
    var message = Object.keys(state).find(function (x) {
      return state[x].focused;
    });
    return message ? React.createElement(AriaLiveMessage, {
      "aria-live": "polite"
    }, React.createElement("p", null, message)) : null;
  }, [state]);
  var createEventHandlers = React.useCallback(function (message) {
    return {
      onFocus: function onFocus() {
        return dispatch({
          type: actionTypes.FOCUS,
          message: message
        });
      },
      onBlur: function onBlur() {
        return dispatch({
          type: actionTypes.BLUR,
          message: message
        });
      }
    };
  }, []);
  var reader = React.useCallback(function (message) {
    if (!state[message]) {
      var handlers = createEventHandlers(message);
      dispatch({
        type: actionTypes.SET,
        message: message,
        handlers: handlers
      });
      return handlers;
    }

    return state[message].handlers;
  }, [state]);

  var read = function read(message) {
    return dispatch({
      type: actionTypes.FOCUS,
      message: message
    });
  };

  return {
    a11y: a11y,
    reader: reader,
    read: read
  };
};

exports.default = useScreenReader;
